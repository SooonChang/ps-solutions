# 병사 배치하기
!!!  

https://www.acmicpc.net/problem/18353

## 풀이
이 문제의 기본 아이디어는 '***가장 긴 증가하는 부분 수열***'(LIS, Longest Increasing Subsequence)로 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같다.  
&nbsp;

'LIS' 문제란, 하나의 수열이 주어졌을 때 값들이 증가하는 형태의 가장 긴 부분 수열을 찾는 문제이다.
&nbsp;

### 예제
예를 들어 하나의 수열 array = {10, 20, 10, 30, 20, 50}가 있다고 하자.  
이때 가장 긴 증가하는 부분 수열은 {10, 20, 30, 50}이 될 것이다.  
$D[i]$ 를 $array[i]$ 를 마지막 원소로 가지는 부분 수열의 최대 길이라고 정의하면, 가장 긴 증가하는 부분 수열을 계산하는 점화식은 다음과 같다. 이때 초기의 DP 테이블의 값은 모두 1로 초기화한다.

$$ D[i] = max(D[i], D[j] + 1) \quad if\ array[j] < array[i], \quad for\ all\ 0\le j < i $$

&nbsp;

테이블이 갱신되는 과정을 그림으로 확인해보면, i를 1부터 n-1까지 증가시키며, 점화식에 따라 테이블을 갱신했을 때의 결과는 다음과 같다.  

|array|10|20|10|30|20|50|
|---|---|---|---|---|---|---|
|init|1|1|1|1|1|1|
|i = 1|1|**2**|1|1|1|1|
|i = 2|1|2|**1**|1|1|1|
|i = 3|1|2|1|**3**|1|1|
|i = 4|1|2|1|3|**2**|1|
|i = 5|1|2|1|3|2|**4**|

최종적으로 테이블의 값은 {1, 2, 1, 3, 2, 4}이고, 이렇게 테이블에 남아있는 값 중에서 가장 큰 값이 가장 긴 증가하는 부분 수열의 기이이다. 즉, 현재 예시에서는 4가 최장 길이가 된다.

위와 같이, 조건을 if array[j] > array[i]로 변경하여 문제를 해결할 수 있다.

## 코드
<details>
<summary> 첫 번째 풀이 </summary>

```python
import sys
input = sys.stdin.readline

n = int(input())
data = list(map(int, input().split()))

dp = [1] * n

for i in range(1, n):
    for j in range(0, i):
        if data[j] > data[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(n - max(dp))
```
</details>